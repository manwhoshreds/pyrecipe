#!/usr/bin/env python
# -*- encoding: UTF-8 -*-
# PYTHON_ARGCOMPLETE_OK
"""
    recipe_tool
    ~~~~~~~~~~~
    
    recipe_tool is the frontend commandline interface to
    the pyrecipe library.
"""
import argparse

import argcomplete

from pyrecipe import config, Recipe, db, __scriptname__

def recipe_completer(**kwargs):
    """List of recipes for completer."""
    data = db.get_data()
    recipe_names = data['recipe_names']
    return recipe_names

def build_recipe_database():
    """Build the recipe database."""
    database = db.RecipeDB()
    database.create_database()
    for item in config.RECIPE_DATA_FILES:
        r = Recipe(item)
        database.add_recipe(r)

def parse_args():
    """Parse args for recipe_tool."""
    parser = argparse.ArgumentParser(
        description="Recipe_tool has tab completion functionality. \
                     After adding a recipe, simply run recipe_tool \
                     print <TAB><TAB> to view whats available.",
        add_help=False
    )
    parser.add_argument(
        "-h", "--help",
        action='help',
        help='Show this help message and quit'
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Increase the verbosity of output. \
              Only works with print and show subcommands."
    )
    parser.add_argument(
        "-V",
        "--version",
        dest="version",
        action="store_true",
        help="Print version and exit"
    )
    # <-- Subparsers start here -->
    subparser = parser.add_subparsers(dest='subparser')

    # recipe_tool print
    parser_print = subparser.add_parser(
        "print", 
        help="Print the recipe to screen"
    )
    parser_print.add_argument(
        "source", 
        help="Recipe to print"
    ).completer = recipe_completer

    parser_print.add_argument(
        "-y", 
        "--yield",
        default=0,
        nargs='?',
        type=int,
        dest="yield_amount",
        help="Specify a yield for the recipe."
    ).completer = recipe_completer
    
    # recipe_tool edit
    parser_edit = subparser.add_parser(
        "edit", 
        help="Edit a recipe data file"
    )
    parser_edit.add_argument(
        "source", 
        type=str, 
        help="Recipe to edit"
    ).completer = recipe_completer

    # recipe_tool add
    parser_add = subparser.add_parser("add", help='Add a recipe')
    parser_add.add_argument("name", help='Name of the recipe to add')
    
    # recipe_tool remove
    parser_remove = subparser.add_parser("remove", help='Delete a recipe')
    parser_remove.add_argument(
        "source", 
        help='Recipe to delete'
    ).completer = recipe_completer
    
    # recipe_tool make
    parser_make = subparser.add_parser(
        "make", 
        help='Make a recipe using the urwid automated script'
    )
    parser_make.add_argument(
        "source", 
        help='Recipe to make'
    ).completer = recipe_completer
    
    # recipe_tool shop
    parser_shop = subparser.add_parser("shop", help='Make a shopping list')
    parser_shop.add_argument(
        "recipes",
        nargs="*",
        help='List of recipe to compile shopping list'
    ).completer = recipe_completer
    
    parser_shop.add_argument(
        "-a",
        "--add",
        nargs='?',
        type=str,
        help="Add an ingredient or a list of ingredients to the current "
             "shopping list."
    )
    parser_shop.add_argument(
        "-c",
        "--commit",
        action="store_true",
        help="Commit the current shopping list to a remote server."
    )
    parser_shop.add_argument(
        "-p",
        "--print-list",
        action="store_true",
        help="Print the current shopping list."
    )
    parser_shop.add_argument(
        "-r",
        "--random",
        nargs='?',
        const=config.RAND_RECIPE_COUNT,
        type=int,
        metavar="NUM",
        dest="random",
        help="Pick n random recipes for the week"
    )
    parser_shop.add_argument(
        "-s",
        "--save",
        action="store_true",
        help="Save the current shopping list."
    )
    # recipe_tool dump
    parser_dump = subparser.add_parser(
        "dump",
        help="Dump yaml or xml representation of recipe stdout"
    )
    parser_dump.add_argument(
        "source",
        help="Recipe to dump data from"
    ).completer = recipe_completer
    
    parser_dump.add_argument(
        "-x",
        "--xml",
        dest="data_type",
        action="store_const",
        const="xml",
        help="Dump sorce xml tree to standard output"
    )
    parser_dump.add_argument(
        "-y",
        "--yaml",
        dest="data_type",
        action="store_const",
        const="yaml",
        help="Dump source yaml to standard output"
    )
    parser_dump.add_argument(
        "-r",
        "--raw",
        dest="data_type",
        action="store_const",
        const="raw",
        help="Dump source data in its raw format"
    )
    # recipe_tool export
    parser_export = subparser.add_parser(
        "export",
        help="Export recipes in xml format"
    )
    parser_export.add_argument(
        "source",
        help="Sorce file to export"
    ).completer = recipe_completer
    
    parser_export.add_argument(
        "-o",
        "--output-dir",
        dest="output_dir",
        type=str,
        nargs="?",
        help="Choose a directory to output file"
    )
    parser_export.add_argument(
        "-a",
        "--all",
        help="Export all files in the database"
    )
    parser_export.add_argument(
        "-x",
        "--xml",
        dest="xml",
        action='store_true',
        help="Export file in xml format"
    )
    parser_export.add_argument(
        "-r",
        "--recipe",
        dest="recipe",
        action='store_true',
        help="Export recipe file"
    )
    # recipe_tool show
    parser_show = subparser.add_parser(
        "show",
        help="Show statistic from the reicpe database"
    )
    # recipe_tool fetch
    parser_fetch = subparser.add_parser(
        "fetch",
        help="Fetch a recipe from a website. \
              (currently only supports tasty.co, more to come)"
    )
    parser_fetch.add_argument(
        "url",
        nargs="?",
        default=None,
        help="Url of a recipe to fetch"
    )
    parser_fetch.add_argument(
        "-e",
        "--edit",
        action="store_true",
        help="Open the recipe in the editor. Select this to save the recipe"
    )
    parser_fetch.add_argument(
        "--list-sites",
        action="store_true",
        help="List the sites that {} can download from".format(__scriptname__)
    )
    parser_fetch.add_argument(
        "--search",
        help="Search the web for a recipe to scrape"
    )

    # auto completion
    argcomplete.autocomplete(parser)
    
    args = parser.parse_args()
    import sys
    if len(sys.argv) == 1:
        sys.exit(parser.print_help())
    elif len(sys.argv) == 2 and args.verbose:
        # if recipe_tool is invoked with only a verbose flag it 
        # causes an exception so here we offer help if no other 
        # flags are given
        sys.exit(parser.print_help())
    else:
        return args

def main():
    """Main entry point of recipe_tool."""
    args = parse_args()
    import pyrecipe.argfuncs as argfunc
    action = {
        'print': argfunc.print_recipe,
        'edit': argfunc.edit_recipe,
        'add': argfunc.add_recipe,
        'remove': argfunc.delete_recipe,
        'make': argfunc.make_recipe,
        'fetch': argfunc.fetch_recipe,
        'shop': argfunc.print_shopping_list,
        'dump': argfunc.dump_data,
        'export': argfunc.export_recipes,
        'show': argfunc.show_statistics,
    }
    if args.version:
        argfunc.version(args)
    else:
        action[args.subparser](args)

if __name__ == '__main__':
    """Build the database first if it doesnt exist."""
    import os, sys
    if not os.path.exists(config.DB_FILE):
        print('Building recipe database...')
        build_recipe_database()
    sys.exit(main())
